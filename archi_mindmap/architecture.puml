@startuml
title R-Type Architecture - Complete UML Class Diagram
skinparam packageStyle rectangle
skinparam linetype ortho

package "Network Layer" {
    class PacketManager {
        - uint32_t _send_seqid
        - uint32_t _recv_seqid
        + handlePacketBytes(data: uint8_t*, size: size_t)
        + sendPacketBytesSafe(data: void*, size: size_t, type: uint8_t)
        + fetchReceivedPackets()
        + fetchPacketsToSend()
    }

    class PacketHandler {
        + registerHandler(type: uint8_t, handler: function)
        + processPacket(packet: packet_t)
    }

    class packet_t {
        + packet_header_t header
        + void* data
    }

    class packet_header_t {
        + uint32_t seqid
        + uint32_t ack
        + uint8_t type
        + uint32_t auth
        + uint32_t data_size
    }

    PacketManager --> packet_t : manages
    PacketHandler --> packet_t : processes
    packet_t *-- packet_header_t : contains
}

package "ECS Core" {
    class World {
        - EntityManager m_entityManager
        - ComponentManager m_componentManager
        + CreateEntity(): EntityID
        + DestroyEntity(entity: EntityID)
        + AddComponent<T>(entity: EntityID, args...): T*
        + GetComponent<T>(entity: EntityID): T*
        + HasComponent<T>(entity: EntityID): bool
        + GetAllComponents<T>(): ComponentArray<T>*
        + GetAllEntities(): vector<EntityID>
        + Clear()
    }

    class EntityManager {
        - std::vector<bool> m_aliveEntities
        - std::queue<EntityID> m_freeEntities
        + CreateEntity(): EntityID
        + DestroyEntity(entity: EntityID)
        + IsEntityAlive(entity: EntityID): bool
        + GetAllEntities(): vector<EntityID>
        + Clear()
    }

    class ComponentManager {
        - std::unordered_map<ComponentTypeID, unique_ptr<IComponentArray>> m_componentArrays
        + AddComponent<T>(entity: EntityID, args...): T*
        + GetComponent<T>(entity: EntityID): T*
        + RemoveComponent<T>(entity: EntityID)
        + HasComponent<T>(entity: EntityID): bool
        + GetAllComponents<T>(): ComponentArray<T>*
        + Clear()
    }

    abstract class Component {
        + {static} GetStaticTypeID(): ComponentTypeID
    }

    World *-- EntityManager : contains
    World *-- ComponentManager : contains
    ComponentManager --> Component : manages
}

package "Common Components" {
    class Position {
        + float x, y
        + Position(x: float, y: float)
    }

    class Velocity {
        + float vx, vy
        + Velocity(vx: float, vy: float)
    }

    class Health {
        + int current
        + int max
        + Health(hp: int)
        + takeDamage(amount: int)
        + heal(amount: int)
    }

    class Player {
        + string name
        + unsigned int serverId
        + Player(name: string, serverId: uint)
    }

    class Projectile {
        + float damage
        + EntityID owner
    }

    class FireRate {
        + float rate
        + float cooldown
        + canFire(): bool
    }

    class Collision {
        + float width, height
        + bool isSolid
    }

    class Team {
        + uint8_t team
    }

    class Score {
        + int value
    }

    Position --|> Component
    Velocity --|> Component
    Health --|> Component
    Player --|> Component
    Projectile --|> Component
    FireRate --|> Component
    Collision --|> Component
    Team --|> Component
    Score --|> Component
}

package "Client GUI System" {
    abstract class State {
        + {abstract} update(deltaTime: float)
        + {abstract} render(window: RenderWindow)
        + {abstract} handleInput(event: Event)
    }

    class StateManager {
        - stack<unique_ptr<State>> states
        + pushState(state: State)
        + popState()
        + update(deltaTime: float)
        + render(window: RenderWindow)
    }

    class MainMenuState {
        + update(deltaTime: float)
        + render(window: RenderWindow)
        + handleInput(event: Event)
    }

    class GameState {
        - World world
        - Network network
        + update(deltaTime: float)
        + render(window: RenderWindow)
        + handleInput(event: Event)
    }

    class TextureCache {
        - map<string, Texture> textures
        + load(path: string): Texture
        + get(path: string): Texture
    }

    class MusicManager {
        - Music currentMusic
        + play(path: string)
        + stop()
        + setVolume(volume: float)
    }

    State <|-- MainMenuState
    State <|-- GameState
    StateManager o-- State : manages
    GameState --> World : uses
    GameState --> TextureCache : uses
    GameState --> MusicManager : uses
}

package "Server Systems" {
    class RoomService {
        - vector<Room> rooms
        + createRoom(): RoomID
        + joinRoom(roomId: RoomID, playerId: PlayerID)
        + leaveRoom(roomId: RoomID, playerId: PlayerID)
    }

    class PlayerService {
        - map<PlayerID, PlayerData> players
        + addPlayer(id: PlayerID, data: PlayerData)
        + removePlayer(id: PlayerID)
        + getPlayer(id: PlayerID): PlayerData
    }

    class GameRules {
        + checkCollisions(world: World)
        + spawnEnemies(world: World, deltaTime: float)
        + updateScore(world: World)
    }

    RoomService --> World : manages
    PlayerService --> World : uses
    GameRules --> World : operates on
}

package "Utilities" {
    class MapParser {
        + parseMap(path: string): MapData
        + loadEntities(world: World, map: MapData)
    }

    class EntityFactory {
        + {static} createPlayer(world: World, x: float, y: float): EntityID
        + {static} createEnemy(world: World, x: float, y: float): EntityID
        + {static} createProjectile(world: World, x: float, y: float): EntityID
    }

    MapParser --> World : populates
    EntityFactory --> World : creates entities in
}

@enduml